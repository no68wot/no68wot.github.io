<!DOCTYPE html>
<html>
<head>
  <meta http-equiv="X-UA-Compatible" content="IE=edge, chrome=1" />
  <meta charset="utf-8" /> <!-- HTML5 -->
  <meta http-equiv="content-type" content="text/html; charset=utf-8" /> <!-- HTML 4.x -->
  <meta http-equiv="expires" content="0" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" /> 
  <style type="text/css">
    html{ margin: 0; padding: 0; }
    body { margin: 0; padding: 0 2px; }
    .myEntry { width: 100%; }
    .myEntry h3 { max-width: 100%; padding: 8px 12px; background-color: #F241B4; color: #fff; font-weight: 800; border-radius: 8px; box-shadow: 0 6px 8px -1px rgba(0,0,0,.9);}
    .fig { padding : 8px; }
    .codeFrame, .fig { max-width: 100%; border: none; box-shadow: 0 0 3px 0 gray; }
    .codeFrame { background-color: ##F5F6CE; }
    .codeFont { font-family: Monospace; font-size: 14px; color: #9a2efe; }
    .codeNum { border-spacing: 0; border-collapse: collapse; float: left; }
    table.codeNum { margin: 0 4px 0 2px; color: #000; background-color: #F2F2F2; }
    table.codeNum td { /* cellpadding="0" */ padding: 0; text-align: right; }
    .keyword { padding: 3px 12px; font-family: monospace; font-size: 15px; font-weight: 800; color: #fff; background-color: #3FE142; border-radius: 3px; box-shadow: -3px -4px 0 1px rgba(50,50,50,.8); text-shadow: 0 2px 0 rgba(0,0,0,1); }
  </style>
  <title>Vietnamese Keyboard</title>
</head>
<body>
<!-- ==================== PAGE_WRAPPER =========================================== -->
<div id="page_wrapper">

<!--********************* ENTRY ************************************-->
<div class="myEntry">
  <h3>Vietnamese Typing Font</h3>
  <form id="frm_viettype" name="Formular" action="">
    <fieldset>
      <input type="radio" id="vn" name="Auswahl" value="vietnamese">
        <label for="vn">Vietnamese</label>
      </input>
      <input type="radio" id="nonvn" name="Auswahl" value="non-vietnamese" checked="checked">
        <label for="nonvn">Non-Vietnamese</label>
      </input>
    </fieldset>
    <textarea id="txtarea" name="Eingabe" rows="10" style="max-width:100%;">Start writing here...</textarea>
  </form>
  <!-- REFERNCES -->
  <table id="tabRefs">
   <tr>
      <td>
        <a href="contents/viet_unicode.html" target="_blank" style="color:red;">Soni's Vietnamese Unicode Table</a>
      </td>
    </tr>
   <tr>
      <td>
        <a href="http://hobieuchanh.com/pages/baiviet/DungVu/DautiengViet.pdf" target="_blank" style="color:orange;">Duy Vũ (2006): <i>Vấn đề đánh dấu thăng tiếng Việt</i>, S.18</a>
         [<a href="resources/vietnamesisch/DautiengViet.pdf" target="_blank">Mirror</a>]
      </td>
    </tr>
    <tr>
      <td>
        <a href="https://vi.wikipedia.org/wiki/Quy_t%E1%BA%AFc_%C4%91%E1%BA%B7t_d%E1%BA%A5u_thanh_trong_ch%E1%BB%AF_qu%E1%BB%91c_ng%E1%BB%AF" target="_blank">
        Wikipedia: <i>Quy tắc đặt dấu thanh trong chữ quốc ngữ</i></a>
      </td>
    </tr>
    <tr>
      <td>
        <a href="http://vietunicode.sourceforge.net/charset/v3.htm" target="_blank">http://vietunicode.sourceforge.net/charset/v3.htm</a>
      </td>
    </tr>
    <tr>
      <td>
        <a href="http://www.ascii.cl/htmlcodes.htm" target="_blank">http://www.ascii.cl/htmlcodes.htm</a>
      </td>
    </tr>
    <tr>
      <td>
        <a href="http://graphemica.com/%C4%83" target="_blank">http://graphemica.com/%C4%83</a>
      </td>
    </tr>
    <tr>
      <td>
        <a href="http://www.character-code.com/" target="_blank">http://www.character-code.com/</a>
      </td>
    </tr>
  </table>
</div> <!--******** END myEntry ********-->

<!--********************* ENTRY ************************************-->
<div class="myEntry">
<h3>5G (5th Generation Mobile Networks / Wireless Systems)</h3>
<div style="max-width:46%;padding:6px 50px 6px 0;float:left;">
<span class="keyword">WRC 2019</span> diskutiert u. identifiziert zusätzliche Frequenzbänder.
</div>
<div style="padding:6px;">
<span class="keyword">IEEE</span> mm-wave wireless communication, outdoor- and indoor 
scenarios: <span style="color:red;">28, 38, 60 and 72-73 GHz</span> bands (Wiki 5G [42][43]).
</div>
</div> <!--******** END myEntry ********-->

<!--********************* ENTRY ************************************-->
<div class="myEntry">
<h3>Java : Object Reference und Typecasting</h3>
<p>Gegeben seien folgende 3 Klassen (A.java, B.java, Main.java):</p>
<pre class="codeFrame codeFont">
/* A.java */
public class A
{
  <span style="color:red;">public void print(A a) {
    System.out.println("print(a) in A");
  }</span>
}
</pre>
<pre class="codeFrame codeFont">
/* B.java */
public class B extends A
{
  public void print(B b) {
    System.out.println("print(b) in B");
  }

  @Override
  <span style="color:red;">public void print(A a) {
    System.out.println("print(a) in B");
  }</span>
}
</pre>
<pre class="codeFrame codeFont">
/**
 * Main.java 
 */
public class Main
{
  public static void main(String[] args) {
    B b = new B();
    A a = b;
    a.print(b); // print(a) in B
    a.print(a); // print(a) in B
    b.print(a); // print(a) in B
    b.print(b); // print(b) in B
  }
}
</pre>
<p>
B ist Unterklasse (Subclass) von A, wegen <span class="codeFont">B extends A</span>. 
Deshalb erbt B alle Eigenschaften und Methoden von A und kann diese sogar überschreiben.
Original-Methode in A und überschriebene/geerbte Methode in B werden im obigen Beispiel 
<span style="color:red">rot</span> markiert.
</p>
<p>
In <span style="color:green">Main.java</span>, betrachte zunächst nur die Anweisung 
<span class="codeFont">new B()</span>. Diese bewirkt, dass eine Instanz (Objekt) :B der 
Klasse B erzeugt wird, wie es die folgende Abbildung illustriert.
<pre class="codeFont fig">
                                new B();

  Klasse                         Objekt
+---------+    instance of     +---------+ 
|    B    |<-------------------|   :B    |
+---------+                    +---------+
</pre>
Anstelle von <span class="codeFont">instance of</span> kann der UML-Stereotyp <span class="codeFont">
&lt;&lt;instance&gt;&gt;</span> verwendet werden.<br />
<br />
Dann wird durch die Zuweisung <span class="codeFont">B b = new B()</span> das erzeugte Objekt :B der
Variable b zugewiesen. Die Variable b hat den Typ B und ist ein Pointer (Zeiger, Referenz) auf 
Objekt :B.
<pre class="codeFont fig">
                                           B b = new B();
  Klasse                         Objekt
+---------+    instance of     +---------+                 
|    B    |<-------------------|   :B    |<-------------- b
+---------+                    +---------+
</pre>
Mit der Anweisung <span class="codeFont">A a = b</span> wird die Referenz von b der Variable a 
zugewiesen. Die Referenz von b ist das Objekt :B. Die Variable a ist ein Pointer vom Typ A und 
zeigt nun durch die o.g. Zuweisung ebenfalls auf Objekt :B. Also a zeigt auf das, was b auch 
zeigt. Die folgende Abbildung illustriert diesen Sachverhalt. Außerdem kann i.d.R. an dem 
erzeugten Objekt :B nichts mehr geändert werden.
<pre class="codeFont fig">
                                           B b = new B();
                                           A a = b = new B()
  Klasse                         Objekt
+---------+    instance of     +---------+                 
|    B    |<-------------------|   :B    |<-------------- b
+---------+                    +----^----+
                                    |
                                    +-------------------- a
</pre>
Die Anweisung <span class="codeFont">a.print(b)</span> bewirkt, dass a (Typ A) zunächst scheinbar 
die Methode <span class="codeFont">print(A a)</span> der Klasse A aufrufen "soll". Diese Methode
<span class="codeFont">print(A a)</span> von A wird bereits in der Klasse B überschrieben (@Override).
Außerdem zeigt a (trotz Typs A) nur auf Objekt :B (Typ B). Deshalb kann a nicht auf die Original-Methode
<span class="codeFont">print(A a)</span> in A zugreifen, sondern muss die geerbte und überschriebene 
Methode <span class="codeFont">print(A a)</span> in B aufrufen. (Die andere Methode 
<span class="codeFont">print(B b)</span> kommt für a <b>nicht</b> infrage, denn sie ist eigene 
Methode von B, und nicht von A).
<pre class="codeFont fig">
    Klasse
+------------+
|     A      |
+------------+
| print(A a) |
+------------+
      ^
     /_\
      |
      | extends                             B b = new B();
      |                                     A a = b = new B()
      |                            Objekt
+------------+    instance of     +---------+                 
|     B      |<-------------------|   :B    |<-------------- b
+------------+                    +----^----+
| print(A a) |                         |
| print(B b) |                         +-------------------- a
+------------+
</pre>
Zusammengefasst: a ist vom Typ A, a muss Methode <span class="codeFont">print(A a)</span> von A 
aufrufen, kann aber nicht. Denn a ist kein Pointer (Referenz) auf irgendein Objekt :A der Klasse A.
(Es gibt auch kein Objekt :A). Stattdessen ist a ein Pointer auf Objekt :B der Klasse B. Und die 
Methode <span class="codeFont">print(A a)</span> von A wird von B geerbt 
(<span class="codeFont">B extends A</span>) und überschrieben (@Override). 
Die beehrte Methode <span class="codeFont">print(A a)</span> existiert aslo auch im Objekt 
:B. So muss a (trotz Typs A) auf diese Methode <span class="codeFont">print(A a)</span> in B 
zugreifen.<br />
Die Methode <span class="codeFont">print(A a)</span> erwartet ein Argument (Parameter) vom Typ A.
In der Anweisung <span class="codeFont">a.print(b)</span> ist b (Typ B) das Argument. Wegen 
<span class="codeFont">B extends A</span> ist b auch vom Typ A. Und das genügt der Funktion 
<span class="codeFont">print(A a)</span> in B. Daher liefert die Anweisung 
<span class="codeFont">a.print(b)</span> die Meldung
<span class="codeFont" style="color:green">print(a) in B</span>.
<pre class="codeFont" style="color:green">
a.print(b) ==> a.print(b : B extends A) ==> a.print(A a) ==> "print(a) in B"
                                              (in B)
</pre>
Die nächste Anweisung <span class="codeFont">a.print(a)</span> verhält sich (fast) identisch wie
die vorherige <span class="codeFont">a.print(b)</span>. Der einzige Unterschied hier ist das Argument
a (anstatt b). Da a vom Typ A ist, ergibt der Aufruf <span class="codeFont">a.print(a)</span>
dieselbe Meldung <span class="codeFont" style="color:green">print(a) in B</span>.
<pre class="codeFont" style="color:green">
a.print(a) ==> a.print(a : A) ==> a.print(A a) ==> "print(a) in B"
                                    (in B)
</pre>
Die nächste Anweisung <span class="codeFont">b.print(a)</span> kann wie folgt verstanden werden:
b ist ein Pointer auf das (durch <span class="codeFont">new B()</span>) erzeugte Objekt :B.
Mit <span class="codeFont">b.print(..)</span> wird eine gewisse Methode <span class="codeFont">
print(..)</span> von B (bzw. :B) aufgerufen. Es gibt aber zwei solche 
(<span class="codeFont">print(A a)</span> und <span class="codeFont">print(B b)</span>) in B. 
Welche von denen gewählt wird, hängt vom Typ des erwarteten Arguments ab.
In der Anweisung <span class="codeFont"> b.print(a)</span> ist das Argument a vom Typ A. 
Also ist das jetzt klar, welche print-Methode aufgerufen werden soll, nämlich 
<span class="codeFont">print(A a)</span>.
<pre class="codeFont" style="color:green">
b.print(a) ==> b.print(a : A) ==> b.print(A a) ==> "print(a) in B"
                                    (in B)
</pre>
Die letzte Anweisung <span class="codeFont">b.print(b)</span> hat b (Typ B) im Argument.
(Argument ist das was zwischen den Klammern steht).
So wird die Methode <span class="codeFont">print(B b)</span> von B (bzw. :B) aufgerufen.
<pre class="codeFont" style="color:green">
b.print(b) ==> b.print(b : B) ==> b.print(B b) ==> "print(b) in B"
                                    (in B)
</pre>
</p>
</div> <!--******** END myEntry ********-->


</div>
<!-- ==================== END PAGE_WRAPPER ======================================= -->

<script type="text/javascript">
 (function () { 
	/** Formatting references ************************************/
 	var vArr = document.querySelectorAll("table#tabRefs tr") || []; /* NodeList */
	if ( vArr.length === 0 ) return;
	var ll = vArr.length;
	for ( var i = 0; i < ll; i++ ) {
 		var firstChild = vArr[i].querySelector("td");
		var td = document.createElement("TD");
 		td.appendChild(document.createTextNode("[" + (i+1) + "]"));
		vArr[i].insertBefore(td, firstChild);
	}

	/** Formatting comments in code sections *********************/
	var vArr = document.querySelectorAll("pre.codeFrame") || []; /* NodeList */
	if ( vArr.length === 0 ) return;
	var ll = vArr.length; // Number of all existing <pre> containers.
	var nLines = 0; // Number of lines in every <pre> container.
	var parentNode = vArr[0].parentNode; // Get reference to parent node.
	// Iterates the number of <pre> containers
	for ( var i = 0; i < ll; i++ ) {
	  var strCode = vArr[i].innerHTML;
	  // Count the number of line feeds.
	  nLines = strCode.split(/\r\n|\r|\n/g).length;
	  if ( nLines > 0 ) {
	    var tab = document.createElement("TABLE");
	    for ( var j = 1; j < nLines; j++ ) {
	      var tr = document.createElement("TR");
	      var td = document.createElement("TD");
	      td.appendChild(document.createTextNode(j + "|"));
	      tr.appendChild(td);
	      tab.appendChild(tr);
	    }
	    tab.setAttribute("class", "codeNum codeFont");
	    parentNode.insertBefore(tab, vArr[i]);
	  }
	  // Regular expression for code comments. Supports: /* */ and //
	  var strReg = "\/(\\*)[ ]*.*[ ]*(\\*)+\/" // Comment in the kind of /*..*/
	             + "|\/\/[ ]*.*[\n\r]" // Comment in the kind of: //
	             + "|\/(\\*)([A-Za-z0-9äöüÄÖÜ_ ]|[^A-Za-z0-9äöüÄÖÜ_ ])*[\n\r\t ]*(\\*)\/";
	  var re = new RegExp(strReg, "gi");
	  /* https://developer.mozilla.org/de/docs/Web/JavaScript/Reference/Global_Objects/String/replace */
	  vArr[i].innerHTML = strCode.replace(re, function (match, p, offset, string) { 
	    return "<span style='color:green;'>" + match + "</span>";
	  });
	}
 })();
</script>

<script type="text/javascript">
/**
 * Soni D.
 */
 var VNKeyboard = (function () {
	 var g = {
		frmObj : null, /* Form object */
		rbViet : null, /* Radio button Viet */
		rbNoViet : null, /* Radio button No Viet */
		txtarea : null,
		isFocused : false, /* focus on textarea */
		vietOn : false,
		vietCode : { a  : ['a', 'á', 'à', 'ả', 'ã', 'ạ'],   // 0
		             a6 : ['â', 'ấ', 'ầ', 'ẩ', 'ẫ', 'ậ'],   // 1
		             a8 : ['ă', 'ắ', 'ằ', 'ẳ', 'ẵ', 'ặ'],   // 2 
		             e  : ['e', 'é', 'è', 'ẻ', 'ẽ', 'ẹ'],   // 3
		             e6 : ['ê', 'ế', 'ề', 'ể', 'ễ', 'ệ'],   // 4
		             i  : ['i', 'í', 'ì', 'ỉ', 'ĩ', 'ị'],   // 5
		             o  : ['o', 'ó', 'ò', 'ỏ', 'õ', 'ọ'],   // 6
		             o6 : ['ô', 'ố', 'ồ', 'ổ', 'ỗ', 'ộ'],   // 7
		             o7 : ['ơ', 'ớ', 'ờ', 'ở', 'ỡ', 'ợ'],   // 8
		             u  : ['u', 'ú', 'ù', 'ủ', 'ũ', 'ụ'],   // 9
		             u7 : ['ư', 'ứ', 'ừ', 'ử', 'ữ', 'ự'],   // 10
		             y  : ['y', 'ý', 'ỳ', 'ỷ', 'ỹ', 'ỵ'],   // 11
		             A  : ['A', 'Á', 'À', 'Ả', 'Ã', 'Ạ'],   // 12
		             A6 : ['Â', 'Ấ', 'Ầ', 'Ẩ', 'Ẫ', 'Ậ'],   // 13
		             A8 : ['Ă', 'Ắ', 'Ằ', 'Ẳ', 'Ẵ', 'Ặ'],   // 14
		             E  : ['E', 'É', 'È', 'Ẻ', 'Ẽ', 'Ẹ'],   // 15
		             E6 : ['Ê', 'Ế', 'Ề', 'Ể', 'Ễ', 'Ệ'],   // 16
		             I  : ['I', 'Í', 'Ì', 'Ỉ', 'Ĩ', 'Ị'],   // 17
		             O  : ['O', 'Ó', 'Ò', 'Ỏ', 'Õ', 'Ọ'],   // 18
		             O6 : ['Ô', 'Ố', 'Ồ', 'Ổ', 'Ỗ', 'Ộ'],   // 19
		             O7 : ['Ơ', 'Ớ', 'Ờ', 'Ở', 'Ỡ', 'Ợ'],   // 20
		             U  : ['U', 'Ú', 'Ù', 'Ủ', 'Ũ', 'Ụ'],   // 21
		             U7 : ['Ư', 'Ứ', 'Ừ', 'Ử', 'Ữ', 'Ự'],   // 22
		             Y  : ['Y', 'Ý', 'Ỳ', 'Ỷ', 'Ỹ', 'Ỵ'],   // 23
	 			},
	 };
	 return {
		 init : function () {
			 /* Form object */
			  g.frmObj = document.forms[0]; // document.Formular
			 /* Radio buttons */
			  g.rbViet = g.frmObj.Auswahl[0];
			  g.rbNoViet = g.frmObj.Auswahl[1];
			 /* Textarea */
			  g.txtarea = g.frmObj.Eingabe;
			 /* Add formatting properties */
			  g.txtarea.style.padding = "8px";
			  g.txtarea.style.backgroundColor = "#fff";
			  g.txtarea.style.font = "normal 20px 'Verdana'"; /* font-style font-size font-family */
			  g.txtarea.style.border = "2px solid #F78181";
			  //g.txtarea.style.boxShadow = "inset 0 0 4px 1px rgba(89,89,89,.2)";
			  this.setStyle(g.txtarea, "boxShadow", "inset 0 0 4px 1px rgba(89,89,89,.2)");
			  this.setStyle(g.txtarea, "borderRadius", "8px");
			 /* Add event listeners */
			  g.rbViet.addEventListener('click', function () { g.vietOn = true; }, false);
			  g.rbNoViet.addEventListener('click', function () { g.vietOn = false; }, false);
			  g.txtarea.addEventListener('click', function () {
				  if ( !g.isFocused ) {
					  g.txtarea.value = "";
					  g.isFocused = true;
				  }
			  }, false);
			  //g.txtarea.addEventListener('keydown', ( evt ) => this.vietKeyDown( evt ), false);
			  g.txtarea.addEventListener('keydown', function ( evt ) { VNKeyboard.vietKeyDown( evt ) }, false);
			  //g.txtarea.addEventListener('keyup', ( evt ) => this.vietKeyUp( evt ), false);
			  g.txtarea.addEventListener('keyup', function ( evt ) { VNKeyboard.vietKeyUp( evt ) }, false);
		 }, // init
		 
		 isIn : function ( el /* object */, vSet /* set of objects */ ) {
			 for ( var prop in vSet ) {
				 var arr = vSet[prop], ll = arr.length;
				 console.log(Object.prototype.toString.call(arr));
				 for ( var i = 0; i < ll; ++i ) {
					 if ( el == arr[i] )
						 return true;
				 }
			 }
			 return false;
		 }, // isIn
		 
		 getCursorPos : function () {
			 var cursorPos; /* Integer */
			 if ( document.selection ) { // IE older than 11
				 console.log("Here");
				 /* MSDN (selection): A document can have one selection at one time. Although an empty selection
				  * contains nothing, one can use it to mark a position in the document.				  *
				  */
				 var oRange = document.selection.createRange();
				 // Todo
			 } else if ( g.txtarea.selectionStart || g.txtarea.selectionStart == 0 ) { // FF, Chrome
				 /* If no text is selected, |selectionStart| contains the index of the character that follows the input cursor. */
				 cursorPos = g.txtarea.selectionStart; // g.txtarea.selectionEnd
			 }
			 return cursorPos;
		 }, // getCursorPos
		 
		 vietKeyDown : function ( evt ) {
			 var key = evt.key;
			 if ( key == undefined || key === "Unidentified" ) return;
			 var code = key.charCodeAt(0); // evt.keyCode || evt.which;
			 if ( code >= 48 && code <= 57 ) {
				 var txt = g.txtarea.value; // content (text) of textarea			 	
				 var lc = txt.substr(this.getCursorPos()-1, 1); // last char	 			 	
				 if ( /[a-zâăêôơư]/.test(lc) ) /* regular expression: matches every char that is letter (from a until z) or vocal with apostrophe (â,ă,ê,ô,ơ,ư) */
				 	evt.preventDefault(); // disable (prevent) keyboardEvent for numeric character
			 }
		 }, // vietKeyDown
		 
		 vietKeyUp : function ( evt ) {
			 var sgn, code, txt, cursorPos, li, lc, llc, lllc, tmp, offset = 0;
			 sgn = evt.key; // current key (sign, char)
			 if ( sgn == undefined || sgn === "Unidentified" ) return;
			 code = sgn.charCodeAt(0);
			 if ( code >= 48 && code <= 57 ) {
				 txt = g.txtarea.value; // content (text) of textarea
				 cursorPos = this.getCursorPos();
				 li = cursorPos - 1; // txt.length - 1; // last (char) index				 	
				 lc = txt.substr(li,1); // last char				 
				 if ( /[a-zâăêôơư]/.test(lc) ) { /* regular expression: matches every char that is letter (from a until z) or vocal with apostrophe (â,ă,ê,ô,ơ,ư) */
				 	llc = ( li-1 < 0 ) ? "" : txt.substr(li-1, 1); // next to last | last last char
				 	lllc = ( li-2 < 0 ) ? "" : txt.substr(li-2, 1); // last last last char
				 	switch ( lc ) {
				 		case "a": // ??a
				 			if ( sgn == "6" ) lc = 'â';
				 			else if ( sgn == "8" ) lc = 'ă';
				 			else if ( sgn >= 1 && sgn <= 5 ) { // á, à, ả, ã, ạ
				 				this.getCursorPos();
				 				if ( /[iou]/.test(llc) ) { // ?a : ia, oa, ua
				 					if ( lllc == "q" && llc == "u" || lllc == "g" && llc == "i" ) { 
				 						// Special cases: "qu" and "gi" become "phụ âm" if there is a vocal follwing them respectively, e.g. : quá, già, AND NOT qúa, gìa 
				 						lc = g.vietCode.a[sgn]; 
				 					} else { // ?[iou]a : bia, bìa, hoa, hóa, mua, múa
				 						llc = ( llc == "i" ) ? g.vietCode.i[sgn] : ( llc == "o" ) ? g.vietCode.o[sgn] : /* u */ g.vietCode.u[sgn];
				 					}
				 				} else { // ?a : ba, bà, la, là
				 					lc = ( !this.isIn(llc, g.vietCode) ) ? g.vietCode.a[sgn] : lc + sgn;
				 				}
				 			} else {
				 				lc += sgn;
				 				offset = 1;
				 			}
				 			break;
				 		case "e": // ??e
				 			if ( sgn == "6" ) lc = 'ê';
				 			else if ( sgn >= 1 && sgn <= 5 ) { // é, è, ẻ, ẽ, ẹ
				 				if ( llc == "o" ) { // ?e : oe, òe
				 					llc = g.vietCode.o[sgn];
				 				} else {
				 					lc = g.vietCode.e[sgn];
				 					// Special cases are also included: "qu" and "gi" become "phụ âm" if there is a vocal follwing them respectively, e.g. : què, giẻ, AND NOT qùe, gỉe 
				 				}
				 			} else {
				 				lc += sgn;
				 				offset = 1;
				 			}
				 			break;
				 		case "i": // ??i
				 			if ( sgn >= 1 && sgn <= 5 ) { // i, í, ì, ỉ, ĩ, ị
				 				if ( /[aoôơuư]/.test(llc) ) { // ?i : ài, ói, ùi, chuối
				 					llc = ( llc == "a" ) ? g.vietCode.a[sgn] : ( llc == "o" ) ? g.vietCode.o[sgn] : ( llc == "u" ) ? g.vietCode.u[sgn] :
				 						  ( llc == "ô" ) ? g.vietCode.o6[sgn] : ( llc == "ơ" ) ? g.vietCode.o7[sgn] : /* ư */ g.vietCode.u7[sgn];
				 				} else {
				 					lc = ( !this.isIn(llc, g.vietCode) ) ? g.vietCode.i[sgn] : lc + sgn;
				 				}
				 			} else {
				 				lc += sgn;
				 				offset = 1;
				 			}
				 			break;
				 		case "o": // ??o
				 			if ( sgn == "6" ) lc = 'ô';
				 			else if ( sgn == "7" ) lc = 'ơ';
				 			else if ( sgn >= 1 && sgn <= 5 ) { // ó, ò, ỏ, õ, ọ
				 				if ( llc == "a" || llc == "e" ) { // ?o : áo, èo
				 					llc = ( llc == "a" ) ? g.vietCode.a[sgn] : /* e */ g.vietCode.e[sgn];
				 				} else { 
				 					lc = ( !this.isIn(llc, g.vietCode) ) ? g.vietCode.o[sgn] : lc + sgn;
				 					// Special cases included : "qu" and "gi" become "phụ âm" if there is a vocal follwing them respectively, e.g. : quó, giò, AND NOT qúo, gìo
				 				}
				 			} else {
				 				lc += sgn;
				 				offset = 1;
				 			}
				 			break;
				 		case "u": // ??u
				 			if ( sgn == "7" ) lc = 'ư';
				 			else if ( sgn >= 1 && sgn <= 5 ) { // ú, ù, ủ, ũ, ụ
				 				if ( llc == "a" || llc == "i" ) { // ?u : àu, íu, giù
				 					if ( lllc == "g" && llc == "i" ) { 
				 						// Special cases: "qu" and "gi" become "phụ âm" if there is a vocal follwing them respectively, e.g. : giù, AND NOT gìu 
				 						lc = g.vietCode.u[sgn]; 
				 					} else { // ?[ai]u : àu, íu
				 						llc = ( llc == "a" ) ? g.vietCode.a[sgn] : /* i */ g.vietCode.i[sgn];
				 					}
				 				} else { // ?u : hú, lù, tù
				 					lc = ( !this.isIn(llc, g.vietCode) ) ? g.vietCode.u[sgn] : lc + sgn;
				 				}
				 			} else {
				 				lc += sgn;
				 				offset = 1;
				 			}
				 			break;
				 		default: // Vocal with apostrophe (â,ă,ê,ô,ơ,ư),'y' and consonant (Konsonant bzw. Mitlaut)
				 			/* â,ă,ê,ô,ơ,ư gn*/
				 			var prop = ( lc == "â" ) ? "a6" : ( lc == "ă" ) ? "a8" : ( lc == "ê" ) ? "e6" : ( lc == "ô" ) ? "o6" : ( lc == "ơ" ) ? "o7" : ( lc == "ư" ) ? "u7" : ( lc == "y" ) ? "y" : null;
				 			if ( prop ) {
				 				if ( sgn >= 1 && sgn <= 5 ) {
				 					lc = g.vietCode[prop][sgn];
				 				} else {
				 					lc += sgn;
				 					offset = 1;
				 				}
				 			} else if ( lc == "d" && sgn == 9 ) {
				 				lc = "đ";
				 			} else {
				 				console.log("here");
				 				lc += sgn;
				 				offset = 1;
				 			}
				 			/* TODO:
				 			 * Checks the consonant (e.g. b,c,d,e,...) following a vocal (e.g. a,e,i,o,u,â,ă,ê,ô,ơ,ư,y)
			 				 * Hat ein Wort ein Konsonant (Wortlaut) am Wortende, dann setze Zeichen (Apostroph) auf den LETZTEN Vokal im Wort.
			 				 * => ??n: thần, thánh, trường, thắng, hoàng, quyền
			 				 *
			 				 * In den obigen Beispielen sind jeweils 'ơ' (trường), 'a' (hoàng), 'ê' (quyền) der LETZTE Vokal.
			 				 * Daher wird der Apostroph entsprechend auf sie gesetzt:  ơ => ờ => trư(ờ)ng | a => à => ho(à)ng | ê => ề => quy(ề)n
			 				 */
				 			break;
				 	}
				 	tmp = txt.substring(0,li-1) + llc + lc + txt.substring(li+1, txt.length);
				 	// Set cursor (caret) to the current position. Avoid the case that cursor springs to text end.
				 	g.txtarea.value = txt.substring(0,li-1) + llc + lc + txt.substring(li+1, txt.length);
				 	g.txtarea.selectionStart = tmp.length - tmp.substring(cursorPos, tmp.length).length + offset;
				 	g.txtarea.selectionEnd = g.txtarea.selectionStart;
				 }
				 	
			 }
		 }, // vietKeyUp
		 
		 /* Set style property with prefix vendor */
		 setStyle : function ( el, prop, val ) {
			 /* callback (anonymous function) is called with 3 arguments: curElem (value of current array element), index, array */
			 var vProp = prop.charAt(0).toUpperCase() + prop.substr(1);
			 ["Webkit", "Moz", "ms", "O"].forEach( function ( curElem, index, array ) {
				 el.style[curElem + vProp] = val;
			 });
			/* el.style["Webkit" + vProp] = val;
			 * el.style["Moz" + vProp] = val;
			 */
			 el.style[prop] = val;
		 }
	 }
 })();
 
 //document.addEventListener("DOMContentLoaded", () => VNKeyboard.init(), false);
 document.addEventListener("DOMContentLoaded", function () { VNKeyboard.init(); }, false);
</script>

</body>
</html>
